float4x4 matWorldViewProj;
float4x4 matWorld;
float3 vecViewPosition;
float4 vecFogColor;
float fFogStart;
float fFogEnd;
float3 vecHeightFog;
float4 vecOceanColor;

struct VS_OUTPUT
{
    float4 Position   : POSITION;   // vertex position     
    float2 Texture    : TEXCOORD0;
    float  Fog		  : TEXCOORD1;
    float  OceanFog   : TEXCOORD2;
};

sampler ColorTextureSampler : register(s0);

VS_OUTPUT TerrainSimple_Shader_vs( float4 vPos : POSITION,							  
								   float2 vTexCoord0 : TEXCOORD0 )
{	
	VS_OUTPUT Output;	
	Output.Position = mul( vPos, matWorldViewProj );
    Output.Texture = vTexCoord0;
    float3 vecPos = mul( vPos, matWorld );
    float fLens = length( vecPos - vecViewPosition );
    Output.Fog = saturate( ( fLens - fFogStart ) / ( fFogEnd - fFogStart ) );
	if( vecPos.y < vecHeightFog.y )
	{
		float3 vecV = vecPos - vecViewPosition;
		float fX = ( vecHeightFog.y - vecViewPosition.y ) / vecV.y;
		float3 vecP = vecViewPosition + fX * vecV;
		Output.OceanFog = saturate( length( vecP - vecPos ) / vecHeightFog.z );
	}
	else
	{
		Output.OceanFog = 0;
	}
    
    return Output;
}

half4 TerrainSimple_Shader_ps( float2 Tex : TEXCOORD0,
							   float  Fog : TEXCOORD1,
							   float  OceanFog : TEXCOORD2 ) : COLOR
{	
	half4 vecColorTex = tex2D( ColorTextureSampler, Tex );				
	vecColorTex.xyz = lerp( vecColorTex.xyz, vecFogColor.xyz, Fog );
	vecColorTex.xyz = lerp( vecColorTex.xyz, vecOceanColor.xyz, OceanFog );
	return vecColorTex;	
}