
float4x4 matWorldViewProj;
float4x4 matWorld;
float3 vecViewPosition;
float3 vecSunDirection;
float3 vecSunColor;		
float3 vecSkyColor;
float fMultiplySunColor;
float fMultiplyHorizonColor;
float3 vecHorizonColor;
float fHorizonExp;
float fSunExp;
float fFogStart;
float fFogEnd;
float fScatterEnd;
float3 vecScatterStartColor;
float3 vecScatterEndColor;
float fMultiplyScatter;
float4 vecFogColor;
float4 vecLowFogColor;

float4x4 matSunInvLightDirection;
float4 vecTerrainLightIntensity;	
float3 vecShadowColor;
float3 vecSunLightDirection;
float3 vecPViewPosition;
float3 vecSpecularColor;
float3 vecHeightFog;
float4 vecOceanColor;


struct VS_OUTPUT
{
    float4 Position   : POSITION;   // vertex position     
    float2 Texture    : TEXCOORD0;
    float3 Pos : TEXCOORD1;
    float4 Fex : TEXCOORD2 ;
    float4 Lin : TEXCOORD3 ;
    float2 DetailTextureX : TEXCOORD4;
    float2 DetailTextureY : TEXCOORD5;
    float2 CliffTextureX : TEXCOORD6;
    float2 CliffTextureY : TEXCOORD7;    
};

sampler ColorTextureSampler : register(s0);
sampler BlendTextureSampler : register(s1);
sampler ShadingTextureSampler : register(s2);
sampler NormalTextureSampler : register(s4);
sampler TangentUSampler : register(s5);

sampler Detail1 : register(s6);
sampler Detail2 : register(s7);
sampler DetailNormal1 : register(s8);
sampler DetailNormal2 : register(s9);

//samplerCUBE LightSampler : register( s8 );

void HoffmanScattering( in float4 vecPosition, out float3 vecLin, out float3 vecFex )
{
	float4 vecTransformPosition = mul( vecPosition, matWorld );
	float3 vecViewDirection = vecTransformPosition - vecViewPosition;
	float fLens = length( vecViewDirection );
		
	vecViewDirection = normalize( vecViewDirection );
	
	float fTheta = saturate( dot( vecSunDirection, vecViewDirection ) );
	float fSunTheta = pow( fTheta, fSunExp );
	
	float3 vecXYDirection = vecViewDirection;	
	vecXYDirection.y = 0.0f;	
	vecXYDirection = normalize( vecXYDirection );		
		
	float3 vecHorizon = pow( saturate( dot( vecXYDirection, vecViewDirection ) ), fHorizonExp ) * vecHorizonColor * fMultiplyHorizonColor;
	
	vecSunColor = float3( 0.0f, 0.0f, 0.0f );
	
	float3 vecInscatter = vecSunColor * fSunTheta * fMultiplySunColor + vecFogColor;// + vecHorizon;		
	
	float fPhase1 = 1.0f + fTheta * fTheta;		
	
	float fFogRate = saturate( ( fLens - fFogStart ) / ( fFogEnd - fFogStart ) );
	fFogRate *= fPhase1;	
		
	vecInscatter = lerp( float3( 0.0f, 0.0f, 0.0f ), vecInscatter * fPhase1, fFogRate );		
	
	
	vecLin = vecInscatter;	
		
	float fScatterRate = saturate( fLens / fScatterEnd );
	vecFex = lerp( vecScatterStartColor, vecScatterEndColor, fScatterRate ) * fMultiplyScatter;		
}


VS_OUTPUT TerrainMulti_Shader_vs( float4 vPos : POSITION,							  
								  float2 vTexCoord0 : TEXCOORD0 )
{	
	VS_OUTPUT Output;	
	Output.Position = mul( vPos, matWorldViewProj );
    Output.Texture = vTexCoord0;    
    
    ///////////////////////////////////////////    
    
    float3 vecFex, vecLin;
    
    HoffmanScattering( vPos, vecLin, vecFex );        
	
	Output.Fex.xyz = vecFex;	
	Output.Lin.xyz = vecLin * 0.4f;
	
	float3 vecTransformPosition = mul( vPos, matWorld );
	
	Output.DetailTextureX = float2( vTexCoord0.x * 10.0f, vecTransformPosition.y * -0.0004f );	
    Output.DetailTextureY = float2( vecTransformPosition.y * -0.0004f, vTexCoord0.y * 10.0f );
    
    Output.CliffTextureX = float2( vTexCoord0.x * 10.0f, vecTransformPosition.y * -0.0004f ) * float2( 0.3f, 0.3f );
    Output.CliffTextureY = float2( vecTransformPosition.y * -0.0004f, vTexCoord0.y * 10.0f ) * float2( 0.3f, 0.3f );
    Output.Pos = mul( vPos, matWorld );
    float fLens = length( Output.Pos - vecViewPosition );    
    Output.Fex.w = saturate( ( fLens - fFogStart ) / ( fFogEnd - fFogStart ) );    
    
    // 12.06 Ocean Underwater Fog.. vecHeightFog.z = Ocean Height    
	if( Output.Pos.y < vecHeightFog.y )
	{
		float3 vecV = Output.Pos - vecViewPosition;
		float fX = ( vecHeightFog.y - vecViewPosition.y ) / vecV.y;
		float3 vecP = vecViewPosition + fX * vecV;
		Output.Lin.w = saturate( length( vecP - Output.Pos ) / vecHeightFog.z );
	}
	else
	{
		Output.Lin.w = 0;
	}

    return Output;
}
float4 TerrainMulti_Shader_ps( float2 Tex : TEXCOORD0,
						 float3 Pos : TEXCOORD1,
						 float4 Fex : TEXCOORD2,
						 float4 Lin : TEXCOORD3,
						 float2 DetailTextureX : TEXCOORD4,
						 float2 DetailTextureY : TEXCOORD5,
						 float2 CliffTextureX : TEXCOORD6,
						 float2 CliffTextureY : TEXCOORD7 ) : COLOR
{
	half3 vecDetailMask = tex2D( BlendTextureSampler, Tex );	
	half3 vecDetailLayer1 = tex2D( Detail1, DetailTextureY );
	half3 vecDetailLayer2 = tex2D( Detail1, DetailTextureX );				
	
	half3 vecCliffX = tex2D( ColorTextureSampler, CliffTextureX );
	half3 vecCliffY = tex2D( ColorTextureSampler, CliffTextureY );	
	half3 vecCliff = lerp( vecCliffY, vecCliffX, vecDetailMask.y );		
	
	half4 vecDetailNormalLayer1 = tex2D( DetailNormal1, DetailTextureY );
	half4 vecDetailNormalLayer2 = tex2D( DetailNormal1, DetailTextureX );	
	
	half4 vecDetailNormalTex = lerp(  vecDetailNormalLayer1, vecDetailNormalLayer2, vecDetailMask.y );			
//	half fSpecular = ( vecDetailNormalTex.w - 0.5f ) * 2.0f;
	half fSpecular = vecDetailNormalTex.w * 2.0f;
	
	half3 NormalTex = ( tex2D( NormalTextureSampler, Tex ) - 0.5f ) * 2.0f;
	half3 TangentUTex = ( tex2D( TangentUSampler, Tex ) - 0.5f ) * 2.0f;			
	half3 TangentVTex = cross( TangentUTex, NormalTex );			
	vecDetailNormalTex.xyz = ( vecDetailNormalTex - 0.5f ) * 2.0f;	
		
	half3x3 matRotate;	
	matRotate._11 = TangentUTex.x;
	matRotate._21 = TangentVTex.x;
	matRotate._31 = NormalTex.x;
	
	matRotate._12 = TangentUTex.y;
	matRotate._22 = TangentVTex.y;
	matRotate._32 = NormalTex.y;
	
	matRotate._13 = TangentUTex.z;
	matRotate._23 = TangentVTex.z;
	matRotate._33 = NormalTex.z;		
	
	half3 vecTransNormal = mul( vecDetailNormalTex, matRotate );
	//vecTransNormal = NormalTex;
	float3 vecLight = dot( vecTransNormal, vecSunLightDirection );	
	
	//vecLight = max( vecLight * vecTerrainLightIntensity.x, vecShadowColor );			
	half3 vecShadow = tex2D( ShadingTextureSampler, Tex );	
	vecLight *= vecTerrainLightIntensity.x;
	vecLight *= vecShadow;
	vecLight = max( vecLight, vecShadowColor );
	//vecDetailTex *= vecLight;			
	//float3 vecColor = lerp( vecDetailLayer1, vecDetailLayer2, vecDetailMask.y ) * max( tex2D( ShadingTextureSampler, Tex ), float4( vecShadowColor, 1.0f ) ) * vecTerrainLightIntensity.x;	
	
	float3 vecColor = saturate( lerp( vecDetailLayer1, vecDetailLayer2, vecDetailMask.y ) * vecLight );	
	
	float3 vecSpecular = pow( saturate ( dot( normalize( normalize( vecPViewPosition - Pos ) + vecSunLightDirection ) ,normalize( vecTransNormal ) ) ), 30.0f  ) * fSpecular * vecSpecularColor;		
	vecColor = vecColor * vecCliff;
	vecColor.xyz += vecSpecular;
	float4 vecColorTex = float4( vecColor * Fex + Lin.xyz, vecDetailMask.r + vecDetailMask.y  );
	vecColorTex.xyz = lerp( vecColorTex.xyz, vecLowFogColor.xyz, Fex.w );	
	vecColorTex.xyz = lerp( vecColorTex.xyz, vecOceanColor.xyz, Lin.w );
	return vecColorTex;
}