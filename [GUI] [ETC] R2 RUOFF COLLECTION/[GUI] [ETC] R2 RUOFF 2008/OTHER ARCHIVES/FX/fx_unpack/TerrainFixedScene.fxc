float4x4 matWorldViewProj;
float4x4 matWorld;
float3 vecViewPosition;
float4 vecLowFogColor;
float fFogStart;
float fFogEnd;
float4 vecScatterEndColor;
float3 vecHeightFog;
float4 vecOceanColor;

struct VS_OUTPUT
{
    float4 Position   : POSITION;   // vertex position     
    float2 Texture    : TEXCOORD0;
    float2 Texture1   : TEXCOORD1;
    float  Fog		  : TEXCOORD3;
    float  OceanFog   : TEXCOORD4;
};

sampler ColorTextureSampler : register(s0);
sampler BlendTextureSampler : register(s1);
	
VS_OUTPUT TerrainFixed_Shader_vs( float4 vPos : POSITION,							  
								  float2 vTexCoord0 : TEXCOORD0 )
{	
	VS_OUTPUT Output;	
	Output.Position = mul( vPos, matWorldViewProj );
    float3 vecPos = mul( vPos, matWorld );
    float fLens = length( vecPos - vecViewPosition );
    Output.Fog = saturate( ( fLens - fFogStart ) / ( fFogEnd - fFogStart ) );

	if( vecPos.y < vecHeightFog.y )
	{
		float3 vecV = vecPos - vecViewPosition;
		float fX = ( vecHeightFog.y - vecViewPosition.y ) / vecV.y;
		float3 vecP = vecViewPosition + fX * vecV;
		Output.OceanFog = saturate( length( vecP - vecPos ) / vecHeightFog.z );
	}
	else
	{
		Output.OceanFog = 0;
	}
    
    Output.Texture = vTexCoord0;
    Output.Texture1 = vTexCoord0 * float2( 80, 80 );
    return Output;
}

float4 TerrainFixed_Shader_ps( VS_OUTPUT In ) : COLOR
{
	float4 vecTexColor = tex2D( ColorTextureSampler, In.Texture );
	float4 vecBlendTexColor = tex2D( BlendTextureSampler, In.Texture1 );
	vecTexColor.xyz = vecTexColor.xyz * vecScatterEndColor.xyz * vecBlendTexColor.xyz * 4;
	vecTexColor.xyz = lerp( vecTexColor.xyz, vecLowFogColor.xyz, In.Fog );
	vecTexColor.xyz = lerp( vecTexColor.xyz, vecOceanColor.xyz, In.OceanFog );
	return vecTexColor;
}