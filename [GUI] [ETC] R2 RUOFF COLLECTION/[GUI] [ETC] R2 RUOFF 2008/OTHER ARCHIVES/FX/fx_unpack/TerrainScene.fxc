float4x4 matWorldViewProj;
float4x4 matWorld;
float3 vecViewPosition;
float3 vecSunLightDirection;
float3 vecSunDirection;
float3 vecSunColor;		
float3 vecSkyColor;
float fMultiplySunColor;
float fMultiplyHorizonColor;
float3 vecHorizonColor;
float fHorizonExp;
float fSunExp;
float fFogStart;
float fFogEnd;
float fScatterEnd;
float3 vecScatterStartColor;
float3 vecScatterEndColor;
float fMultiplyScatter;
float4 vecFogColor;
float4 vecLowFogColor;
float3 vecHeightFog;
float4 vecOceanColor;

float4x4 matShadowCameraProjTexScale;
float4x4 matNearShadowCameraProjTexScale;
float4x4 matShadowProjectionTexScale;
float2 vecNearFarPlane;	

float4x4 matSunInvLightDirection;
float3 vecShadowColor;

float4x4 matLODCharacterShadowCameraProjTexScale;
float4 vecTerrainLightIntensity;
float4 vecCloudShadow;
float3 vecSpecularColor;

struct VS_OUTPUT
{
    float4 Position   : POSITION;   // vertex position     
    float2 Texture    : TEXCOORD0;
    float2 DetailTexture : TEXCOORD1;
    float4 Fex : TEXCOORD2 ;
    float4 Lin : TEXCOORD3 ;
    float3 ViewPosition : TEXCOORD4;
    float2 CloudShadowmapTexture : TEXCOORD5;    
    float3 Pos : TEXCOORD6;
};

sampler ColorTextureSampler : register(s0);
sampler BlendTextureSampler : register(s1);
sampler ShadingTextureSampler : register(s2);
sampler CloudShadowSampler : register(s3);
sampler BlendTexture2Sampler : register(s4);

sampler NormalTextureSampler : register(s5);
sampler TangentUSampler : register(s6);
sampler TangentVSampler : register(s7);

sampler Detail1 : register(s8);
sampler Detail2 : register(s9);
sampler Detail3 : register(s10);
sampler Detail4 : register(s11);

sampler DetailBump1 : register(s12);
sampler DetailBump2 : register(s13);
sampler DetailBump3 : register(s14);
sampler DetailBump4 : register(s15);
	
void HoffmanScattering( in float4 vecPosition, out float3 vecLin, out float3 vecFex )
{
	float4 vecTransformPosition = mul( vecPosition, matWorld );
	float3 vecViewDirection = vecTransformPosition - vecViewPosition;
	float fLens = length( vecViewDirection );
		
	vecViewDirection = normalize( vecViewDirection );
	
	float fTheta = saturate( dot( vecSunDirection, vecViewDirection ) );
	float fSunTheta = pow( fTheta, fSunExp );
	
	float3 vecXYDirection = vecViewDirection;	
	vecXYDirection.y = 0.0f;	
	vecXYDirection = normalize( vecXYDirection );		
		
	float3 vecHorizon = pow( saturate( dot( vecXYDirection, vecViewDirection ) ), fHorizonExp ) * vecHorizonColor * fMultiplyHorizonColor;	
	
	vecSunColor = float3( 0.0f, 0.0f, 0.0f );
	
	float3 vecInscatter = vecSunColor * fSunTheta * fMultiplySunColor + vecFogColor;// + vecHorizon;		
	
	float fPhase1 = 1.0f + fTheta * fTheta;		
	
	float fFogRate = saturate( ( fLens - fFogStart ) / ( fFogEnd - fFogStart ) );
	fFogRate *= fPhase1;	
		
	vecInscatter = lerp( float3( 0.0f, 0.0f, 0.0f ), vecInscatter * fPhase1, fFogRate );		
	
	
	vecLin = vecInscatter;	
		
	float fScatterRate = saturate( fLens / fScatterEnd );
	vecFex = lerp( vecScatterStartColor, vecScatterEndColor, fScatterRate ) * fMultiplyScatter;		
}

float2 CloudShadow( in float4 vPos )
{
	float4 vecPosition = mul( vPos, matWorld );		
	vecPosition.x = vecPosition.x * vecCloudShadow.x;
	vecPosition.y = vecPosition.z * vecCloudShadow.y;
	vecPosition.xy += float2( vecCloudShadow.zw );
	
	return vecPosition;
}


VS_OUTPUT Terrain_Shader_vs( float4 vPos : POSITION,							  
								  float2 vTexCoord0 : TEXCOORD0 )
{	
	VS_OUTPUT Output;	
	Output.Position = mul( vPos, matWorldViewProj );
    Output.Texture = vTexCoord0;
    Output.DetailTexture = vTexCoord0 * float2( 80.0f, 80.0f );            
    
    float3 vecLin, vecFex;
    
    HoffmanScattering( vPos, vecLin, vecFex );
    
    Output.Fex.xyz = vecFex;
    Output.Lin.xyz = vecLin * 0.4f;
    ///////////////////////////////////////////       
	
	//Output.ShadowmapTexture = float4( 1.0f, 1.0f, 1.0f, 1.0f );
	
	//Output.NearShadowmapTexture = mul( vPos, matNearShadowCameraProjTexScale );
	Output.CloudShadowmapTexture = CloudShadow( vPos );
	//Output.CharacterShadowmapTexture = mul( vPos, matShadowProjectionTexScale );
	//Output.LODCharacterShadowmapTexture = mul( vPos, matLODCharacterShadowCameraProjTexScale );	
	Output.Pos = mul( vPos, matWorld );
    float fLens = length( Output.Pos - vecViewPosition );    
    Output.Fex.w = saturate( ( fLens - fFogStart ) / ( fFogEnd - fFogStart ) );    
	
	Output.ViewPosition = vecViewPosition;
    // 12.06 Ocean Underwater Fog.. vecHeightFog.z = Ocean Height    

	if( Output.Pos.y < vecHeightFog.y )
	{
		float3 vecV = Output.Pos - vecViewPosition;
		float fX = ( vecHeightFog.y - vecViewPosition.y ) / vecV.y;
		float3 vecP = vecViewPosition + fX * vecV;
		Output.Lin.w = saturate( length( vecP - Output.Pos ) / vecHeightFog.z );
	}
	else
	{
		Output.Lin.w = 0;
	}
		
    return Output;
}

half4 Terrain_Shader_ps( float2 Tex : TEXCOORD0,
						 float2 DetailTex : TEXCOORD1,
						 float4 Fex : TEXCOORD2,
						 float4 Lin : TEXCOORD3,
						 float3 ViewPosition : TEXCOORD4,
						 float4 CloudShadowmapTex : TEXCOORD5,
						 float3 Pos : TEXCOORD6 ) : COLOR
{	
	half4 vecDetailMask = tex2D( BlendTextureSampler, Tex );				
	half4 vecDetailLayer1 = tex2D( DetailBump1, DetailTex );
	half4 vecDetailLayer2 = tex2D( DetailBump2, DetailTex );
	half4 vecDetailLayer3 = tex2D( DetailBump3, DetailTex );
	half4 vecDetailLayer4 = tex2D( DetailBump4, DetailTex );
	
	half4 vecDetailNormalTex;
	vecDetailNormalTex = lerp( vecDetailLayer1, vecDetailLayer2, vecDetailMask.x );
	vecDetailNormalTex = lerp( vecDetailNormalTex, vecDetailLayer3, vecDetailMask.y );
	vecDetailNormalTex = lerp( vecDetailNormalTex, vecDetailLayer4, vecDetailMask.z );		
//	half fSpecular = saturate( ( vecDetailNormalTex.w - 0.5f ) * 2.0f );
	half fSpecular = vecDetailNormalTex.w * 2.0f;
	
	half3 NormalTex = ( tex2D( NormalTextureSampler, Tex ) - 0.5f ) * 2.0f;
	half3 TangentUTex = ( tex2D( TangentUSampler, Tex ) - 0.5f ) * 2.0f;			
	//half3 TangentVTex = ( tex2D( TangentVSampler, Tex ) - 0.5f ) * 2.0f;				
	
	half3 TangentVTex = cross( TangentUTex, NormalTex );
	
			
	vecDetailNormalTex = ( vecDetailNormalTex - 0.5f ) * 2.0f;
	
	//float3x3 matRotate = float3x3( TangentUTex,TangentVTex, NormalTex );		
	//float3 vecTransNormal = mul( matRotate, vecDetailNormalTex );			
	//vecTransNormal = NormalTex;
	
	half3x3 matRotate;	
	matRotate._11 = TangentUTex.x;
	matRotate._21 = TangentVTex.x;
	matRotate._31 = NormalTex.x;
	
	matRotate._12 = TangentUTex.y;
	matRotate._22 = TangentVTex.y;
	matRotate._32 = NormalTex.y;
	
	matRotate._13 = TangentUTex.z;
	matRotate._23 = TangentVTex.z;
	matRotate._33 = NormalTex.z;		
	
	half3 vecTransNormal = mul( vecDetailNormalTex, matRotate );		
	
	
	//half4 vecColorTex = tex2D( ColorTextureSampler, Tex ) * float4( vecDetailTex, 1.0f ) * max( tex2D( ShadingTextureSampler, Tex ), float4( vecShadowColor, 1.0f ) ) * vecTerrainLightIntensity.x ;			
	//vecColorTex *= max( ( 1.0f - tex2D( CloudShadowSampler, CloudShadowmapTex ).a ), 0.4f );
	//vecColorTex.xyz = vecColorTex.xyz * Fex + Lin;				
	
	float3 vecLight = dot( vecTransNormal, vecSunLightDirection );
	
	vecDetailLayer1 = tex2D( Detail1, DetailTex );
	vecDetailLayer2 = tex2D( Detail2, DetailTex );
	vecDetailLayer3 = tex2D( Detail3, DetailTex );
	vecDetailLayer4 = tex2D( Detail4, DetailTex );
	
	half3 vecDetailTex;		
	vecDetailTex = lerp( vecDetailLayer1, vecDetailLayer2, vecDetailMask.x );
	vecDetailTex = lerp( vecDetailTex, vecDetailLayer3, vecDetailMask.y );
	vecDetailTex = lerp( vecDetailTex, vecDetailLayer4, vecDetailMask.z );			
	vecDetailTex = vecDetailTex * tex2D( ColorTextureSampler, Tex );	
	
	half3 vecShadow = tex2D( ShadingTextureSampler, Tex );
	
	vecLight *= vecTerrainLightIntensity.x;
	vecLight *= vecShadow;
	vecLight = max( vecLight, vecShadowColor );
	vecDetailTex *= vecLight;
		
	float3 vecSpecular = pow( saturate ( dot( normalize( normalize( ViewPosition - Pos ) + vecSunLightDirection ) ,normalize( vecTransNormal ) ) ), 30.0f  ) * fSpecular * vecSpecularColor;		
	//vecLight.xyz += vecSpecular;	
	vecDetailTex.xyz += vecSpecular * vecShadow;
	
	//float3 R = normalize( reflect( , vecTansNormal ) );	
	//float3 vecSpecular = pow( saturate( dot( R, vecSunLightDirection ) ), 8 );
	
		
	float4 vecColorTex;
	vecColorTex.xyz = vecDetailTex * Fex + Lin.xyz;
	//vecColorTex.xyz = vecDetailTex;
	vecColorTex.a = vecDetailMask.a;
//	vecColorTex.xyz = vecSpecular;
	vecColorTex.xyz = lerp( vecColorTex.xyz, vecLowFogColor.xyz, Fex.w );
	vecColorTex.xyz = lerp( vecColorTex.xyz, vecOceanColor.xyz, Lin.w );
	return vecColorTex;	
}	